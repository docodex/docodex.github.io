[{"content":" 官方文档\n全局 cmd + shift + P / F1: 显示命令面板 cmd + J: 显示/隐藏控制台 cmd + P: 快速打开，跳转到某个文件 cmd + shift + N: 打开新窗口 cmd + W: 关闭窗口 cmd + shift + W: 直接关闭窗口（不论是否还有活跃的编辑器） cmd + ,: 用户设置 cmd + K cmd + S: 显示键盘快捷方式 cmd + tab: 切换窗口（这是Mac本身的快捷键） 基础编辑 cmd + X: 剪切（未选中文本的情况下，剪切光标所在行） cmd + C: 复制（未选中文本的情况下，复制光标所在行） opt + Up: 向上移动行 opt + Down: 向下移动行 opt + shift + Up: 向上复制行 opt + shift + Down: 向下复制行 cmd + shift + K: 删除行 cmd + back: 删除当前行光标前的所有字符 cmd + del: 删除当前行光标后的所有字符 opt + back: 把当前单词光标前的字符删除 opt + del: 删除当前单词光标后的字符 cmd + K cmd + X: 删除行尾多余空格 cmd + enter: 下一行插入 cmd + shift + enter: 上一行插入 cmd + [: 减少缩进 cmd + ]: 增加缩进 opt + Left: 跳转到单词最前面 opt + Right: 跳转到单词最末尾 cmd + Left / Home: 跳转到行首 cmd + Right / End: 跳转到行尾 cmd + Up: 跳转到文件开头 cmd + Down: 跳转到文件结尾 cmd + shift + \\: 跳转到匹配的括号 ctrl + PgUp: 按行向上滚动 ctrl + PgDown: 按行向下滚动 cmd + PgUp: 按屏向上滚动 cmd + PgDown: 按屏向下滚动 cmd + opt + [: 折叠代码块 cmd + opt + ]: 展开代码块 cmd + K cmd + [: 折叠全部子代码块 cmd + K cmd + ]: 展开全部子代码块 cmd + K cmd + 0: 折叠全部代码块 cmd + K cmd + J: 展开全部代码块 cmd + K cmd + C: 添加行注释 cmd + K cmd + U: 移除行注释 cmd + /: 添加/移除行注释 opt + shift + A: 添加/移除块注释 opt + Z: 自动换行/取消自动换行 基于单词，行，文档的光标操作加上个shift键，就可以移动光标的同时选择文本；例如，选择当前光标所在位置到当前行最前面的代码：cmd + shift + Left\n多光标与选择 opt + 点击: 插入多个光标 cmd + opt + Up: 向上插入光标 cmd + opt + Down: 向下插入光标 cmd + U: 撤销上一个光标操作 opt + shift + I: 在所选所有行的行尾插入光标 cmd + L: 选中当前行 cmd + shift + L: 选中所有与当前选中内容相同部分 cmd + F2: 选中所有与当前选中单词相同的单词 cmd + ctrl + shift + Left: 折叠选中 cmd + ctrl + shift + Right: 展开选中 opt + shift + 拖动鼠标: 选中代码块 cmd + shift + opt + Up: 列选择 向上 cmd + shift + opt + Down: 列选择 向下 cmd + shift + opt + Left: 列选择 向左 cmd + shift + opt + Right: 列选择 向右 cmd + shift + opt + PgUp: 列选择 向上翻页 cmd + shift + opt + PgDown: 列选择 向下翻页 查找替换 cmd + F: 查找 cmd + opt + F: 替换 cmd + G: 查找下一个 cmd + shift + G: 查找上一个 opt + enter: 选中所有匹配项 cmd + D: 向下选中相同内容 cmd + K cmd + D: 移除前一个向下选中相同内容 代码编辑 ctrl + Space / cmd + I: 打开建议 cmd + shift + Space: 参数提示 tab: Emmet插件缩写补全 opt + shift + F: 格式化 cmd + K cmd + F: 格式化选中内容 F12: 跳转到(类型或符号)定义位置 opt + F12: 小窗口查看(类型或符号)定义内容 cmd + K F12: 分屏查看(类型或符号)定义内容 cmd + .: 快速修复 shift + F12: 显示(对类型或符号的)所有引用 opt + shift + H: 显示对函数的所有调用 cmd + F12: 显示interface的所有实现类型或类型实现的所有接口(适用于go) F2: 重命名符号 cmd + shift + .: 替换为上一个值 cmd + shift + ,: 替换为下一个值 cmd + K M: 更改文件语言 F12：跳转到函数的定义处 cmd + F12：跳转到函数的实现位置；注：js中没有接口的概念，定义和实现是相同的，所以js中的F12和cmd + F12效果是一样的 shift + F12：打开函数引用的预览（把光标放在函数或者类上，按shift + F12可以打开一个引用列表和内嵌编辑器） 导航 cmd + T: 显示所有符号 ctrl + G: 跳转到某行（按行号跳转） cmd + P: 跳转到某个文件 cmd + shift + O: 跳转到某个符号 cmd + shift + M: 打开问题面板 F8: 下一个错误或警告位置 shift + F8: 上一个错误或警告位置 ctrl + shift + tab: 编辑器历史记录 ctrl + -: 后退 ctrl + shift + -: 前进 ctrl + shift + M: tab切换焦点 ctrl + tab(同时按住)，继续按着ctrl键，松开tab键：打开当前打开文件的列表，选择要打开文件，松开ctrl就能打开对应文件 cmd + P打开最近打开文件列表，同时列表顶部出现搜索框，搜索文件名，回车（enter），可以再当前窗口打开对应文件；使用cmd + enter会在新的编辑器窗口打开这个文件 ctrl + G：行跳转，输入对应数字回车，可以跳转到当前文件的当前行 cmd + P(输入文件名 + : + 行数)：跳转到指定文件的指定行数 cmd + shift + O：调出当前文件的符号（函数名等），使用方向键或者搜索，回车，就能跳转到你想要的符号；如果输入:可以对当前文件的所有符号进行分类 cmd + T：打开多个文件，搜索多个文件中的符号 编辑器管理 cmd + W: 关闭编辑器 cmd + K F: 关闭文件夹 cmd + \\: 编辑器分屏 cmd + 1/2/3: 切换到第一/二/三分组 cmd + K cmd + Left: 切换到上一分组 cmd + K cmd + Right: 切换到下一分组 cmd + K cmd + shift + Left: 左移编辑器 cmd + K cmd + shift + Right: 右移编辑器 cmd + K Left: 激活左侧编辑组 cmd + K Right: 激活右侧编辑组 文件管理 cmd + N: 新建文件 cmd + O: 打开文件 cmd + S: 保存文件 cmd + shift + S: 另存为 cmd + opt + S: 全部保存 cmd + W: 关闭文件 cmd + K cmd + W: 全部关闭 cmd + shift + T: 重新打开被关闭的编辑器 cmd + K enter: 保持打开 ctrl + tab: 打开下一个 ctrl + shift + tab: 打开上一个 cmd + K P: 复制当前文件路径 cmd + K R: 在资源管理器中查看当前文件 cmd + K O: 新窗口打开当前文件 显示 cmd + ctrl + F: 全屏、退出全屏 cmd + opt + 0: 切换编辑器（分屏后）分屏方式（横、竖） cmd + + / cmd + shift + +: 放大 cmd + - / cmd + shift + -: 缩小 cmd + B: 显示、隐藏侧边栏 cmd + shift + E: 显示资源管理器 或 切换焦点 cmd + shift + F: 显示搜索框（全局查找） ctrl + shift + G 显示Git面板 cmd + shift + D: 显示调试面板 cmd + shift + X: 显示插件面板 cmd + shift + H: 全局搜索替换 cmd + shift + J: 显示、隐藏高级搜索 cmd + shift + C: 打开新终端 cmd + shift + U: 显示输出面板 cmd + shift + V: Markdown预览窗口 cmd + K V: 分屏显示Markdown预览窗口 调试 F9: 设置 或 取消断点 F5: 开始 或 继续 F11: 进入 shift + F11: 跳出 F10: 跳过 opt + F5: 终止 cmd + K cmd + I: 显示悬停信息 集成终端 ctrl + `: 显示/隐藏终端 ctrl + shift + `: 新建终端 cmd + C: 复制选中内容 cmd + Up: 向上滚动 cmd + Down: 向下滚动 PgUp: 向上翻页 PgDown: 向下翻页 cmd + Home: 滚动到顶部 cmd + End: 滚动到底部 附：Mac键盘符号和修饰键说明 ⌘ command/cmd ⇧ shift ⌥ option/opt/alt ⌃ control/ctrl ↩︎ return/enter ⌫ backspace/back (向光标前删除) ⌦ delete/del (fn + backspace/back) (向光标后删除) ↑ Up ↓ Down ← Left → Right ⇞ Page Up (fn + ↑) ⇟ Page Down (fn + ↓) Home fn + ← End fn + → ⇥ tab (右制表符) ⇤ shift + tab (左制表符) ⎋ escape/esc ","permalink":"https://docodex.github.io/posts/tech/vscode-keymap-for-mac/","summary":"List of almost all VSCode keymap for mac","title":"VSCode Keymap for Mac"},{"content":"SSH 密钥 生成 SSH 密钥 $ ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; 如果系统不支持Ed25519算法，可以使用传统的rsa算法：\n$ ssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; 配置 SSH 公钥到服务器 $ ssh-copy-id -i ~/.ssh/id_ed25519.pub username@server_host 如果使用rsa算法：\n$ ssh-copy-id -i ~/.ssh/id_rsa.pub username@server_host 基本配置 配置个人信息 全局配置 $ git config --global user.name \u0026#34;[name]\u0026#34; $ git config --global user.email \u0026#34;[email address]\u0026#34; $ git config --global color.ui auto 项目配置 $ git config user.name \u0026#34;[name]\u0026#34; $ git config user.email \u0026#34;[email address]\u0026#34; 查看配置 $ git config --list user.name=John Doe user.email=johndoe@example.com 新建 Git 仓库 Server $ cd /git_repository_path $ mkdir project.git $ cd project.git $ git init --bare Initialized empty Git repository in /git_repository_path/project.git/ Client $ git clone git@gitserver:/git_repository_path/project.git $ cd project $ vim README $ git add . $ git commit -m \u0026#39;update the README file\u0026#39; $ git push -u origin master 忽略规则 在 .gitignore 文件中我们可以配置需要忽略哪些文件和文件夹。注意，这个文件仅对还没有被纳入 Git 版本管理的文件生效，要停止已被追踪文件的版本管理可以使用命令git rm --cached。\n规则 空行不匹配作何文件，可以用空行来做来分隔以增强可读性。 以 # 开头的行代表注释。但如果在 # 前面有一个转义字符（\\）则匹配井号（#）。 一般情况下行尾的空格会被忽略，但当空格前有转义字符（\\）时除外。 ! 前缀用于取反，即 ! 后面匹配到的本应该被排除的文件会被加入进来。但如果某文件的父目录已被排除，则该文件不会被再次加入进来，所以任何被包含在其它匹配项里面文件的匹配不会生效，不管它是在哪里配置的。另外，带转义的 !（\\!）匹配 ! 本身。 / 被用作目录分隔符，可被用于匹配模式的开头、中间或末尾。 如果匹配模式开头或中间（或两者都有）存在 /，则模式是相对于 .gitignore 文件所在目录的。否则，模式还会匹配 .gitignore 文件所在目录的任意层次的子目录。 如果匹配模式末尾存在 /，则模式匹配只会匹配目录。否则，模式会匹配目录和文件。 举例说明，doc/frotz/ 会匹配 doc/frotz 目录，但不会匹配 a/doc/frotz 目录；但是，frotz/ 会匹配 frotz，a/frotz 等相对于 .gitignore 文件的所有能匹配的目录。 * 能匹配除 / 之外的任何东西。? 能匹配除 / 之外的任意单个字符。区间模式（如 [a-zA-Z）能匹配在区间内的单个字符。 连续星号（**）对匹配路径名有特殊含义： 以 ** 开头，紧跟着 / 匹配所有目录。例如，**/foo 匹配任意位置的 foo 目录或文件，跟 foo 模式一样；**/foo/bar 匹配任意位置在 foo 目录直接包含的 bar 文件或目录。 以 ** 结尾，匹配里面的所有文件或目录。例如，abc/** 匹配相对于 .gitignore 文件的 abc 目录下的所有文件或目录，不限深度。 / 后面紧跟着 ** 后面再跟 / 匹配零个或多个目录。例如，a/**/b 匹配 a/b，a/x/b，a/x/y/b，等等。 举例 hello.* 匹配任何以 hello. 开头的文件或目录。如果要限制子目录匹配，可以在前面加上 /，如 /hello.*，现在该模式能匹配 hello.txt，hello.c，但不能匹配 a/hello.java。 foo/ 可以匹配任意层次的 foo 目录，但是不能匹配 foo 文件。 doc/frotz 和 /doc/frotz 匹配效果相同，换句话说，如果模式中间有 /，则开头的 / 不是必须的。 foo/* 可以匹配 foo/test.json（一个文件），foo/bar（一个目录），但不会匹配 foo/bar/hello.c，因为单个 * 不会匹配带有 / 的路径。 常用命令 新建/检出仓库 新建本地仓库 $ git init [project-name] 检出仓库 $ git clone [url] 编辑提交 列出所有文件变化（新建或修改），查看仓库状态 $ git status 显示未暂存文件的改动 $ git diff 显示暂存区文件与最近版本的区别 $ git diff --staged 添加文件到暂存区 $ git add [file] $ git add . 取消暂存，但保持文件内容不变 $ git reset [file] 将暂存区内容提交到当前分支 $ git commit -m \u0026#34;[descriptive message]\u0026#34; $ git commit --amend $ git commit --amend --no-edit 注释可以通过单引号来换行\n$ git commit -m \u0026#39; \u0026gt; 1.提交内容 \u0026gt; 2.注释文本 \u0026gt; \u0026#39; git add 和 git commit 可以合在一起写\n$ git commit -am \u0026#34;代码提交注释\u0026#34; $ git commit -a -m \u0026#34;代码提交注释\u0026#34; 操作分支 列出所有本地分支（前面有 * 的为当前分支） $ git branch 查看远程分支 $ git branch -r 查看所有分支（本地 + 远程） $ git branch -a 创建新分支 $ git branch [branch-name] 切换到指定分支并更新工作目录 $ git checkout [branch-name] 创建并切换分支快捷命令（相当于上面两个命令的合体） $ git checkout -b [branch-name] 修改分支名称 $ git branch -m [old-branch-name] [new-branch-name] 切换回主分支 $ git checkout master 合并指定分支到当前分支 $ git merge [branch] 合并分支时，Git 会默认用 Fast forward 模式，此模式下，删除分支后，会丢掉分支信息；而且当所有分支都有改动时，容易出错，建议添加 --no-ff 参数，禁用 Fast forward 模式\n合并分支时，加上 --no-ff 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而 Fast forward 合并就看不出来曾经做过合并。合并时要创建一个新的 commit，所以加上 -m 参数，把 commit 描述写进去。 $ git merge --no-ff -m \u0026#34;merge with --no-ff\u0026#34; [branch-name] 删除指定分支 $ git branch -d [branch-name] 强行删除指定分支 $ git branch -D [branch-name] 变基 git rebase 用法详解与工作原理 $ git rebase \u0026lt;base\u0026gt; # 例如: git rebase master $ git rebase -i \u0026lt;base\u0026gt; $ git rebase --interactive \u0026lt;base\u0026gt; # 命令: # p, pick \u0026lt;提交\u0026gt; = 使用提交 # r, reword \u0026lt;提交\u0026gt; = 使用提交，但修改提交说明 # e, edit \u0026lt;提交\u0026gt; = 使用提交，进入 shell 以便进行提交修补 # s, squash \u0026lt;提交\u0026gt; = 使用提交，但融合到前一个提交 # f, fixup \u0026lt;提交\u0026gt; = 类似于 \u0026#34;squash\u0026#34;，但丢弃提交说明日志 # x, exec \u0026lt;命令\u0026gt; = 使用 shell 运行命令（此行剩余部分） # b, break = 在此处停止（使用 \u0026#39;git rebase --continue\u0026#39; 继续变基） # d, drop \u0026lt;提交\u0026gt; = 删除提交 重构文件 Relocate and remove versioned files\n从工作目录删除文件并暂存此删除操作 $ git rm [file] 从版本控制系统删除文件但保留对应本地文件 $ git rm --cached [file] 修改文件名并准备提交 $ git mv [file-original] [file-renamed] 排除（.gitignore） Exclude temporary files and paths\n列出当前项目所有排除文件 $ git ls-files --other --ignored --exclude-standard 保存工作现场 存储当前工作现场，等以后恢复现场后继续工作 $ git stash 恢复存储的工作现场，恢复的同时把 stash 内容也删掉 $ git stash pop 查看存储的工作现场 $ git stash list 可以多次 stash，恢复的时候，先用 git stash list 查看，然后恢复指定的stash $ git stash apply stash@{0} 丢弃最近存储的工作现场 $ git stash drop 检查历史 列出当前分支版本历史 $ git log 列出文件版本历史，包含重命名。 $ git log --follow [file] log 输出信息压缩命令 $ git log --pretty=oneline 查看指定文件版本库日志 $ git log [filename] 查看分支合并图 $ git log --graph $ git log --graph --pretty=oneline --abbrev-commit 查看 log 参数的更多信息 $ git log --help 查看分支间的差异 $ git diff [first-branch]...[second-branch] 查看分支之间的差异。在合并改动之前，你可以使用如下命令预览差异。 $ git diff [source-branch-name] [target-branch-name] 输出特定提交的元数据和修改的内容 $ git show [commit] 查看HEAD的移动历史 $ git reflog 版本回退 撤回所有提交，但保留本地改动。 $ git reset [commit] 丢弃所有历史和修改并回到特定提交 $ git reset --hard [commit] 回到当前版本，放弃所有没有提交的修改。 $ git reset --hard HEAD 回到上个版本 $ git reset --hard HEAD^ 回到上上个版本 $ git reset --hard HEAD^^ 回到往上的第6个版本 $ git reset --hard HEAD~6 回到指定版本号的版本（3628164 这段数字是 commit id，也就是所谓的版本号，它是一大串字符串的前几位，我们没必要把一整串 commit id 都写出来） $ git reset --hard 3628164 同步修改 Downloads all history from the repository bookmark $ git fetch [bookmark] Combines bookmark’s branch into current local branch $ git merge [bookmark]/[branch] Uploads all local branch commits to GitHub $ git push [alias] [branch] Downloads bookmark history and incorporates changes $ git pull 远程仓库 关联一个远程仓库 $ git remote add origin [url] 第一次推送 master 分支的所有内容，使用 -u 参数，Git 不但会把本地的 master 分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的 master 分支关联起来。此后，每次本地提交后，只要有必要，就可以使用命令 git push origin master 推送最新修改。 $ git push -u origin master 推送最新修改 $ git push origin master 除非你将分支推送到远端仓库，不然他人就看不到该分支 $ git push origin [branch-name] 查看远程仓库地址 $ git remote -v 标签 查看所有标签 $ git tag 切换到需要打标签的分支上，使用下面命令就可以打一个新标签（标签是默认打在最新提交的 commit 上的） $ git tag [tag-name] 打标签到指定的 commit 上 $ git tag [tag-name] [commit-id] 查看标签信息 $ git show [tag-name] 创建带有说明的标签。-a：指定标签名，-m：指定说明文字 $ git tag -a [tag-name] -m \u0026#34;tag description\u0026#34; [commit-id] 删除本地标签 $ git tag -d [tag-name] 推送指定标签到远程 $ git push origin [tag-name] 推送全部尚未推送到远程的本地标签 $ git push origin --tags 删除指定远程标签（在删除远程标签之前，要先从本地删除） $ git push origin :refs/tags/[tag-name] ","permalink":"https://docodex.github.io/posts/tech/welcome-to-git/","summary":"Git tips","title":"Welcome to Git"},{"content":"Vim 基本操作 Vim 分为三种模式：\n输入模式：这就是很普通的编辑器一样，光标在某个位置上闪烁，表示我们可以输入内容了。 普通模式：在输入模式下按下 Esc 键可以退出输入模式，进入到普通模式。 命令模式：执行搜索、替换等命令或调用插件。 普通模式是 Vim 的一大特色，能够进行很多操作，比如：\n快速移动光标 快速替换、删除某些内容 进入输入模式或命令模式 使用 vim 打开文件后，默认进入普通模式，如果我们要编辑文本，可以按下 i 进入编辑模式，编辑完后再按下 Esc 键可以退出输入模式，进入到普通模式。\n如果想退出 vim，则需要借助命令模式。按下 : 并输入以下内容之一：\nq：退出 q!：如果对文件作了修改，无法用 q 退出，此时 q! 表示丢弃修改并退出 wq：保存并退出 Vim 光标移动 上一节中我们介绍了 Vim 的基本操作，靠着 i、q 等指令，配合上方向键，基本上能在 Vim 的世界里幸存下来了。勉强编辑一下服务器上的文件不是问题。\n如果你的打字手势标准的话，你会发现方向键其实挺难触摸到，至少会破坏右手的姿势。因此在 Vim 中不鼓励使用方向键，可以用 hjkl 来代替：\nh：向左移动一个字符 l：向右移动一个字符 j：向下移动一行 k：向上移动一行 重复移动 如果要向上移动 5 行，或者向右移动 10 个字符，我们是不是要重复按下很多次呢？显然只有方向键才要这么做，Vim 中可以用数字来表示重复：\n10j: 向下移动 10 行 5l: 向右移动五个字符 这个操作虽然简单，但是引出了贯穿 Vim 始终的核心思想：就像英语、中文有语法一样，Vim 也有语法。\nVim 的操作可以由若干个部分组合而成，每个部分又有多个可选值（比如光标移动就分上下左右）。Vim 的入门难度高，是因为每个部分都要学习，一下子需要掌握很多新知识点。但 Vim 后期的学习成本很低，因为无非就是各种组合而已。\n还是以光标移动为例，5j 由重复次数和动作组成，后面我们会介绍更多的动作，而且它们的前面都可以加上数字表示重复。\n单词移动 得益于普通模式和语法，Vim 支持强大的单词间移动：\nw 移动光标到下一个单词的词首(word) b 移动光标到上一个单词的词首(begin) e 移动光标到下一个单词的结尾(end) ge 移动光标到上一个单词的结尾(不知道怎么解释了。。。) 这里的单词是有严格约定的，而且不是那么显然，所以个人感觉这几个键并不是特别好用（往往你以为的跳转地址和真实跳转地址可能并不一致）。\n不过如果你把空格当做单词的分隔符，倒是有比较简单的跳转方式，前三个命令都有大写格式：\nW 移动光标到下一个单词的词首(word) B 移动光标到上一个单词的词首(begin) E 移动光标到下一个单词的结尾(end) 这里的单词特指以空格分割。\n同样的，这些移动也支持重复任意多次。\n行和屏幕移动 在行内，^ 表示移动到行首，它会自动忽视掉行首的空格，大部分情况下这是符合预期的，尤其是在代码缩进的情况下。如果想回到行首的空格上，可以用 0。$ 表示移动到行尾。\nVim 的翻页快捷键是：\nCtrl + f：向后翻一页（forward） Ctrl + b：向前翻一页（backward） Ctrl + d：向后翻半页（down） Ctrl + u：向前翻半页（up） 还有几个快捷键可以用于调整页面布局：\nzz：让当前行居中显示，方便浏览上下文 zt：让当前行显示在最上方，方便浏览后面的内容（t 表示 top） zb：让当前行显示在最下方，方便浏览前面的内容（b 表示 bottom） 高级移动 代码中经常遇到括号（包括 (、[ 和 {，也就是大中小三中括号），如果当前光标停留在括号上，按下 % 即可匹配到对应的括号上。\n除此以外，* 和 # 分别表示匹配当前光标下的单词，并移动到下一个单词和上一个单词\n文本编辑 阅读完前两节，相信读者以经能够在 Vim 中自如的移动光标了，不过我们的编辑方式还比较简陋，只能进入编辑模式，像往常一样逐个字符的输入和删除，本节会介绍一些更高级的操作。\n基础文本编辑 在普通模式下，按下 o 会快速进入输入模式，并且在下一行进行编辑。如果按下大写的 O 会在上一行编辑。\n如果想在当前光标位置开始编辑，可以按下 a 或 i，前者表示在光标所在字符的右侧开始编辑，后者表示在左侧开始编辑。\n我们还可以用 I 前往行头开始编辑，或者用 A 跳转到行尾编辑。\n按下 dd 可以快速删除一行，此时被删除的那一行会保存在 Vim 的剪贴板中。这一点类似于系统的 Command + X 剪切，我们可以通过配置 Vim 来选择是否要与系统共享剪贴板。\n普通模式下，按下 p 可以把 Vim 剪贴板中的内容再拷贝出来，注意这里总是会拷贝到下一行或者光标的右侧。因此如果想交换当前行和下一行，可以输入：ddp，这是因为当前被删除的行会复制到下一行的下面。\n如果只想复制，不想删除，可以把命令 p 换成 y（表示：yank）。如果想删除后进入编辑模式，可以把 p 换成 c，比如 cc 表示删除当前行并且从行首开始编辑。\n注意这里的 p、c、y、d 都是动作，和前面说的 j、k、l、h、w、b、e 一样，都支持用数字来重复，比如 2dd 表示删除两行。\n撤销与重做 如果想撤销上一次修改，可以用 u，类似于系统的 Command + z 快捷键。\n如果想重做，可以用 Ctrl + R，类似于系统的 Command + Shift + z 快捷键。\n文本对象 Vim 的文本对象能极大幅度的提高编辑效率，也是 Vim 进阶之路上必须要掌握的概念。\n对于上文介绍的 c、d、y 这些动作来说，作为单独的动作用处并不大，无非就是连续按两下对当前行做一些操作，而文本对象则扮演了语法中名词的概念，提供了更细粒度的操作。比如以下几种操作：\ndiw： 删除一个单词（word） ca\u0026quot;：删除双引号内的文本并编辑（包含双引号自身） yi\u0026quot;：复制双引号内的文本（不包含双引号自身） dtx：向右删除，直到遇到遇到字符 x（不包含 x） 以上三个命令都属于同一大类操作，它们普遍遵循以下模式：\n命令 = 动作 + 数量 + 描述词 + 文本对象\n这类命令通常由三个或四个字母组成：\n第一个字母是动词，包括上文介绍的 c、y、d 等，表示你这个命令的主要目的。 第二个字母是可选的，表示重复几次 第三个字母是对范围的描述，比如 a 表示包含边界，i 不包含，t 表示向右查找，T 向左。 第四个字母是文本对象，可以是内容的字面量描述，比如 \u0026quot;、'、`、\u0026lt;、{、( 等等，也可以是固定单词 这里详细介绍下文本对象，除了字面量外，以下单词有特定的含义：\np：表示段落 s：表示句子 w：表示单词 t：特指标签，一定要具备 \u0026lt;xx\u0026gt;abc\u0026lt;/xx\u0026gt; 的结构，此时的 t 代表 abc 对于字面量的文本对象，除了 \u0026quot;、' 和 ` 这三个引号外，另外几个括号都可以用 b 来表示（block），这样就不用区分大中小和尖括号了。\n搜索与替换 使用 / 进行搜索，搜索默认是匹配大小写的，使用 /pattern\\c 可以强制忽略大小写，使用 /pattern\\C 可以强制匹配大小写。\n使用 :范围s/oldpattern/newpattern/替换模式 可以进行替换。\n如果我们已经进行过搜索，那么 oldpattern 可以省略不写，默认就是上一次的搜索内容。\n最常用的范围是 begin, end，其中 begin 是开始行号，end 是结束行号，表示在第 begin 行到第 end 行之间进行替换，比如：:1,10s/hello/hallo/g 表示把第 1 - 10 行中所有的 hello 换成 hallo。\n范围还有一些简单的表示法：\n.,10 表示当前行到第 10 行，点表示当前行 .,$ 表示当前行到文件末尾，美刀符号表示文件结尾 % 表示 1,$，也就是整个文件，比如全文替换通常写成 :%s/old/new/g .,+2 表示当前行和接下来的两行 上文反复提到的字母 g 其实是一种替换模式，表示替换这个范围内所有出现的 oldpattern，如果不写则只替换第一次出现。常用的模式还有 c，表示替换需要确认（Confirm），i 表示大小写不敏感，I 表示大小写敏感。\n大小写切换 以下是几个常用的，切换大小写的命令\nguu 当前行全部小写，gUU 当前行全部大写 ~ 当前光标下的字符切换大小写, 3~ 当前光标下后面三个字符切换大小写 guiw 当前单词全部小写，gUiw 当前单词全部大写 g~iw 当前单词每个字符大小写交换 列操作 如果有多行文本要做相同的操作，可以借助 Vim 中列操作的概念来快速完成，举一个实际实际的例子，假设有以下这段代码：\nint a; int b; int c; // ... int z; 有一天我们发现 int 不是很准确，要改成：\nuint8_t a; uint8_t b; uint8_t c; // ... uint8_t z; 难道还要手动复制粘贴不成？请看列操作大法：\n首先按下 Ctrl + V 进入列操作模式 然后用 j、k 进行跳转，表示你要操作多少行 这时你对每一行的操作都会应用到所有行上，比如输入 ec，删除单词进入编辑模式 输入 uint_8，按下 Esc 退出编辑，Vim 会自动应用到所有行上。 宏 列操作的本质是多行同时操作，如果每一行的操作类似，但都有细微差别，就需要引入 录制、回放 的概念了。此时可以用 Vim 中的宏。\n一个典型的场景是，我们在写 Markdown：\n1. 第一条 2. 第二条 3. 第三题 ... 10. 第十条 写着写着突然发现，第一条和第二条中间还要加一条，左边的序号就不好处理了，因为我们要把原来的序号 2 到 10 分别加一。\n在 Vim 中，我们“只”需要输入 qajC-aq6@a，相信你一定很想打我，这特么一点也不简单啊。别急，拆开来看：\nqa（q 表示开始录制宏，a 表示录制内容存储在寄存器 a 中） j（向下一行） Ctrl + a（数字加一） q（再按一次 q 表示结束录制） 6@a（把存储在寄存器 a 中的宏执行 6 次） 是不是感觉 So Easy!\n","permalink":"https://docodex.github.io/posts/tech/welcome-to-vim/","summary":"Vim tips","title":"Welcome to Vim"},{"content":"$ go help Go is a tool for managing Go source code. Usage: go \u0026lt;command\u0026gt; [arguments] The commands are: bug start a bug report build compile packages and dependencies clean remove object files and cached files doc show documentation for package or symbol env print Go environment information fix update packages to use new APIs fmt gofmt (reformat) package sources generate generate Go files by processing source get add dependencies to current module and install them install compile and install packages and dependencies list list packages or modules mod module maintenance work workspace maintenance run compile and run Go program telemetry manage telemetry data and settings test test packages tool run specified go tool version print Go version vet report likely mistakes in packages Use \u0026#34;go help \u0026lt;command\u0026gt;\u0026#34; for more information about a command. Additional help topics: buildconstraint build constraints buildmode build modes c calling between Go and C cache build and test caching environment environment variables filetype file types go.mod the go.mod file gopath GOPATH environment variable goproxy module proxy protocol importpath import path syntax modules modules, module versions, and more module-auth module authentication using go.sum packages package lists and patterns private configuration for downloading non-public code testflag testing flags testfunc testing functions vcs controlling version control with GOVCS Use \u0026#34;go help \u0026lt;topic\u0026gt;\u0026#34; for more information about that topic. 通用选项 选项 作用 -a 用于强制重新编译所有涉及的 Go 语言代码包（包括 Go 语言标准库中的代码包），即使它们已经是最新的了。该标记可以让我们有机会通过改动底层的代码包做一些实验。 -n 使命令仅打印其执行过程中用到的所有命令，而不去真正执行它们。如果只想查看或者验证命令的执行过程，而不想改变任何东西，使用它正好合适。 -v 用于打印命令执行过程中涉及的代码包（列出被编译的代码包名称）。这一定包括我们指定的目标代码包，并且有时还会包括该代码包直接或间接依赖的那些代码包。这会让你知道哪些代码包被执行过了。 -work 用于打印命令执行时生成和使用的临时工作目录的名字，且命令执行完成后不删除它。这个目录下的文件可能会对你有用，也可以从侧面了解命令的执行过程。如果不添加此标记，那么临时工作目录会在命令执行完毕前删除。 -x 使命令打印其执行过程中用到的所有命令，并同时执行它们。（而-n参数是不真正执行它们） -race 用于检测并报告指定 Go 语言程序中存在的数据竞争问题。当用 Go 语言编写并发程序的时候，这是很重要的检测手段之一。 go run go run命令用于编译并运行 Go 程序。\ngo run命令专门用来运行命令源码文件。 注意，这个命令不是用来运行所有 Go 的源码文件的！\ngo run命令只能接受一个命令源码文件以及若干个库源码文件（必须同属于main包）作为文件参数，且不能接受测试源码文件。它在执行时会检查源码文件的类型。如果参数中有多个或者没有命令源码文件，那么go run命令就只会打印错误提示信息并退出，而不会继续执行。\ngo run命令会先编译作为文件参数的源码文件，将他们的编译结果，放到一个临时文件夹中，然后再去运行这个编译的结果，这个编译结果包括命令源码文件被编译后生成的可执行文件以及相关库源码文件编译后生成的归档文件。\n下面来看看go run具体做了什么？\n1. 准备如下代码main.go\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello World!\u0026#34;) fmt.Println(\u0026#34;Test command: go run\u0026#34;) } 2. go run配合-n\n执行：\n$ go run -n main.go 输出：\n# # command-line-arguments # mkdir -p $WORK/b001/ cat \u0026gt;$WORK/b001/importcfg \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; # internal # import config packagefile fmt=/Users/xxx/Library/Caches/go-build/f0/f06adbb2b63f00d9707b9f6cde4112bebf661eda9f148ebf53a9d97d65d6d172-d packagefile runtime=/Users/xxx/Library/Caches/go-build/3f/3fd07ccfb543f52c4ae7929592c5a13bef8fce045bb00fcc31e834325c5be513-d EOF cd /Users/xxx/development/GoProjects/programming /Users/xxx/.goenv/versions/1.23.9/pkg/tool/darwin_arm64/compile -o $WORK/b001/_pkg_.a -trimpath \u0026#34;$WORK/b001=\u0026gt;\u0026#34; -p main -lang=go1.23 -complete -buildid YISpSOUo49yo3nM9m5vL/YISpSOUo49yo3nM9m5vL -dwarf=false -goversion go1.23.9 -c=4 -shared -nolocalimports -importcfg $WORK/b001/importcfg -pack ./main.go /Users/xxx/.goenv/versions/1.23.9/pkg/tool/darwin_arm64/buildid -w $WORK/b001/_pkg_.a # internal cat \u0026gt;$WORK/b001/importcfg.link \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; # internal packagefile command-line-arguments=$WORK/b001/_pkg_.a ... modinfo \u0026#34;0w\\xaf\\f\\x92t\\b\\x02A\\xe1\\xc1\\a\\xe6\\xd6\\x18\\xe6path\\tcommand-line-arguments\\nbuild\\t-buildmode=exe\\nbuild\\t-compiler=gc\\nbuild\\tCGO_ENABLED=1\\nbuild\\tCGO_CFLAGS=\\nbuild\\tCGO_CPPFLAGS=\\nbuild\\tCGO_CXXFLAGS=\\nbuild\\tCGO_LDFLAGS=\\nbuild\\tGOARCH=arm64\\nbuild\\tGOOS=darwin\\nbuild\\tGOARM64=v8.0\\n\\xf92C1\\x86\\x18 r\\x00\\x82B\\x10A\\x16\\xd8\\xf2\u0026#34; EOF mkdir -p $WORK/b001/exe/ cd . GOROOT=\u0026#39;/Users/xxx/.goenv/versions/1.23.9\u0026#39; /Users/xxx/.goenv/versions/1.23.9/pkg/tool/darwin_arm64/link -o $WORK/b001/exe/main -importcfg $WORK/b001/importcfg.link -s -w -buildmode=pie -buildid=-joJxXS_qbf1Rk55E1DJ/YISpSOUo49yo3nM9m5vL/YISpSOUo49yo3nM9m5vL/-joJxXS_qbf1Rk55E1DJ -extld=clang $WORK/b001/_pkg_.a $WORK/b001/exe/main 这里可以看到创建了两个临时文件夹 b001 和 exe，先执行了compile命令，然后link，生成了归档文件 pkg.a 和最终可执行文件，最终的可执行文件放在 exe 文件夹里面。命令的最后一步就是执行了可执行文件。\n3. go run配合-work\n举个例子，生成的临时文件可以用go run -work看到，比如当前生成的临时文件夹是如下的路径：\n执行：\n$ go run -work main.go 输出：\nWORK=/var/folders/r5/g9x6_d5n4z14jk1sxp27j9ch0000gn/T/go-build273325625 Hello World! Test command: go run 进入临时文件夹：\n$ cd /var/folders/r5/g9x6_d5n4z14jk1sxp27j9ch0000gn/T/go-build273325625 查看目录结构：\n$ tree . └── b001 ├── _pkg_.a ├── exe │ └── main ├── importcfg └── importcfg.link 3 directories, 4 files 可以看到，最终go run命令是生成了 2 个文件\n一个是归档文件 pkg.a 一个是可执行文件 main go run命令在第二次执行的时候，如果发现导入的代码包没有发生变化，那么go run不会再次编译这个导入的代码包，而是直接静态链接进来。\ngo build go build命令用于编译指定的 Go 源码文件或代码包以及与之相关联的依赖包。\n如果是普通包，当你执行go build命令后，不会产生任何文件。 如果是 main 包，当只执行go build命令后，会在当前目录下生成一个可执行文件。如果需要在$GOPATH/bin目录下生成相应的可执行文件，需要执行go install或者使用go build -o 路径/可执行文件。 如果某个文件夹下有多个文件，而你只想编译其中某一个文件，可以在go build之后加上文件名，例如go build a.go。go build命令默认会编译当前目录下的所有.go文件。 你也可以指定编译输出的文件名。比如，我们可以指定go build -o 可执行文件名，默认情况是你的 package 名(非 main 包)，或者是第一个源文件的文件名（main 包）。 go build会忽略目录下以 “_” 或者 “.” 开头的.go文件。 如果你的源代码针对不同的操作系统需要不同的处理，那么你可以根据不同的操作系统后缀来命名文件。 当代码包中有且仅有一个命令源码文件的时候，在文件夹所在目录中执行go build命令，会在该目录下生成一个与目录同名的可执行文件。 # 执行 go build 之前 $ tree . ├── go.mod └── main.go 1 directory, 2 files # 执行 go build $ go build # 执行 go build 之后 $ tree . ├── go.mod ├── main.go └── programming # 这个就是 go build 编译产物 1 directory, 3 files 下面来看看go build具体做了什么？\n1. go build配合-n\n执行：\n$ go build -n 输出：\nmkdir -p $WORK/b001/ cat \u0026gt;$WORK/b001/importcfg.link \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; # internal packagefile ... ... packagefile ... modinfo \u0026#34;...\u0026#34; EOF mkdir -p $WORK/b001/exe/ cd . GOROOT=\u0026#39;/Users/xxx/.goenv/versions/1.23.9\u0026#39; /Users/xxx/.goenv/versions/1.23.9/pkg/tool/darwin_arm64/link -o $WORK/b001/exe/a.out -importcfg $WORK/b001/importcfg.link -buildmode=pie -buildid=KGXQl67ZYdS3jwdwCZUe/MjHYLdYDE06snCMmFEkm/M_jXbp3RMIXFtGizibbA/KGXQl67ZYdS3jwdwCZUe -extld=clang /Users/xxx/Library/Caches/go-build/9f/9f9b921244f07f03ef44096ba037733c558b8e9830a6b9e3112fb736c31f73ac-d /Users/xxx/.goenv/versions/1.23.9/pkg/tool/darwin_arm64/buildid -w $WORK/b001/exe/a.out # internal mv $WORK/b001/exe/a.out programming rm -rf $WORK/b001/ 可以看到，执行过程和go run大体相同，唯一不同的就是在最后一步：go run是执行了可执行文件，但是go build命令，只是把库源码文件编译了一遍，然后把可执行文件移动到了当前目录的文件夹中。\n注意：go build既不能编译包含多个命令源码文件的代码包，也不能同时编译多个命令源码文件。因为如果把多个命令源码文件作为一个整体看待，那么每个文件中的main函数都属于重名函数，在编译时会抛出重复定义错误。\ngo install go install用于编译和安装 Go 程序或库。\n执行：\n$ go install -n 输出：\nmkdir -p $WORK/b001/ cat \u0026gt;$WORK/b001/importcfg.link \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; # internal packagefile ... ... packagefile ... modinfo \u0026#34;...\u0026#34; EOF mkdir -p $WORK/b001/exe/ cd . GOROOT=\u0026#39;/Users/xxx/.goenv/versions/1.23.9\u0026#39; /Users/xxx/.goenv/versions/1.23.9/pkg/tool/darwin_arm64/link -o $WORK/b001/exe/a.out -importcfg $WORK/b001/importcfg.link -buildmode=pie -buildid=KGXQl67ZYdS3jwdwCZUe/MjHYLdYDE06snCMmFEkm/M_jXbp3RMIXFtGizibbA/KGXQl67ZYdS3jwdwCZUe -extld=clang /Users/xxx/Library/Caches/go-build/9f/9f9b921244f07f03ef44096ba037733c558b8e9830a6b9e3112fb736c31f73ac-d /Users/xxx/.goenv/versions/1.23.9/pkg/tool/darwin_arm64/buildid -w $WORK/b001/exe/a.out # internal mkdir -p /Users/xxx/go/1.23.9/bin/ mv $WORK/b001/exe/a.out /Users/xxx/go/1.23.9/bin/programming rm -rf $WORK/b001/ go install命令在内部实际上分成了两步操作：\n生成结果文件（可执行文件或者 pkg.a 包) 可执行文件： 一般是go install + 带main函数的.go文件 产生的，有函数入口，可以直接运行 pkg.a 包： 一般是go install + 不包含main函数的.go文件 产生的，没有函数入口，只能被调用 把编译好的结果移到$GOPATH/pkg或者$GOPATH/bin go install用于编译并安装指定的代码包及它们的依赖包。当指定的代码包的依赖包还没有被编译和安装时，该命令会先去处理依赖包。与go build命令一样，传给go install命令的代码包参数应该以导入路径的形式提供。并且，go build命令的绝大多数标记也都可以用于go install。\n实际上，go install命令只比go build命令多做了一件事，即：安装编译后的结果文件到指定目录。\n注意：在安装多个库源码文件时有可能遇到如下的问题:\n$ go install xxx1.go xxx2.go xxx3.go go install: no install location for .go files listed on command line (GOBIN not set) 而且，在我们为环境变量GOBIN设置了正确的值之后，这个错误提示信息仍然会出现。 这是因为，只有在安装命令源码文件的时候，命令程序才会将环境变量GOBIN的值作为结果文件的存放目录。而在安装库源码文件时，在命令程序内部的代表结果文件存放目录路径的那个变量不会被赋值。最后，命令程序会发现它依然是个无效的空值。 所以，命令程序会同样返回一个关于“无安装位置”的错误。 这就引出一个结论，我们只能使用安装代码包的方式来安装库源码文件，而不能在go install命令罗列并安装它们。\n另外，go install 命令目前无法接受标记-o以自定义结果文件的存放位置。这也从侧面说明了go install命令不支持针对库源码文件的安装操作。\ngo get go get用于下载并安装依赖或项目。\ngo get常用选项 选项 作用 -d 让命令程序只执行下载动作，而不执行安装动作。有些非常特殊的代码包在安装过程中需要有特殊的处理，我们需要先下载下来，暂时不进行安装动作，此时就可以用-d参数。 -u 让命令程序利用网络来更新已有代码包及其依赖包。默认情况下，该命令只会从网络上下载本地不存在的代码包，而不会更新已有的代码包。 -f 仅在使用-u标记时才有效。该标记会让命令程序忽略掉对已下载代码包的导入路径的检查。如果下载并安装的代码包所属的项目是你从别人那里 fork 过来的，那么这样做就尤为重要了。 -t 让命令程序同时下载并安装指定的代码包中的测试源码文件中依赖的代码包。 -fix 让命令程序在下载代码包后先执行修正动作，而后再进行编译和安装。 -insecure 允许命令程序使用非安全的 scheme（如 HTTP ）去下载指定的代码包。如果你用的代码仓库（如公司内部的 Gitlab ）没有HTTPS 支持，可以添加此标记。请在确定安全的情况下使用它。 这里说明一下-fix参数中的修正动作。比如说我们需要下载并安装的代码包，是在很早以前写的，其中使用的语法可能是 go1.0 版本之前，而我们当前使用的语法时 go1.4，那这其中的一些语法，以及对一些程序实体的使用方式，可能是不兼容的。为了消除这种不兼容，并可以使这个比较久远的代码包，能够被正确的编译和安装，此时就可以使用-fix参数。它会使命令程序，自动的把这些已经废弃的，或者不一样的语法语句、程序实体使用方式，修正成我们当前这个 go 语言版本所使用的方法和方式。\ngo get做了什么 执行：\n$ go get -x github.com/go-errors/errors 输出：\n# get https://goproxy.io/github.com/@v/list # get https://goproxy.io/github.com/go-errors/@v/list # get https://goproxy.io/github.com/go-errors/errors/@v/list # get https://goproxy.io/github.com/go-errors/@v/list: 404 Not Found (1.726s) # get https://goproxy.io/github.com/go-errors/errors/@v/list: 200 OK (2.140s) # get https://goproxy.io/github.com/go-errors/errors/@v/v1.5.1.info # get https://goproxy.io/github.com/@v/list: 404 Not Found (2.144s) # get https://goproxy.io/github.com/go-errors/errors/@v/v1.5.1.info: 200 OK (0.204s) # get https://goproxy.io/github.com/go-errors/errors/@v/v1.5.1.mod # get https://goproxy.io/github.com/go-errors/errors/@v/v1.5.1.mod: 200 OK (0.821s) # get https://sum.golang.google.cn/lookup/github.com/go-errors/errors@v1.5.1 # get https://sum.golang.google.cn/lookup/github.com/go-errors/errors@v1.5.1: 200 OK (1.174s) # get https://sum.golang.google.cn/tile/8/1/575 # get https://sum.golang.google.cn/tile/8/2/002.p/65 # get https://sum.golang.google.cn/tile/8/0/x147/814.p/16 # get https://sum.golang.google.cn/tile/8/0/x147/259 # get https://sum.golang.google.cn/tile/8/1/577.p/102 # get https://sum.golang.google.cn/tile/8/0/x147/259: 200 OK (0.040s) # get https://sum.golang.google.cn/tile/8/2/002.p/65: 200 OK (0.041s) # get https://sum.golang.google.cn/tile/8/1/577.p/102: 200 OK (0.042s) # get https://sum.golang.google.cn/tile/8/0/x147/814.p/16: 200 OK (0.042s) # get https://sum.golang.google.cn/tile/8/1/575: 200 OK (0.043s) # get https://sum.golang.google.cn/tile/8/1/300 # get https://sum.golang.google.cn/tile/8/0/x076/955 # get https://sum.golang.google.cn/tile/8/1/300: 200 OK (0.040s) # get https://sum.golang.google.cn/tile/8/0/x076/955: 200 OK (0.040s) go: downloading github.com/go-errors/errors v1.5.1 # get https://goproxy.io/github.com/go-errors/errors/@v/v1.5.1.zip # get https://goproxy.io/github.com/go-errors/errors/@v/v1.5.1.zip: 200 OK (0.202s) go: added github.com/go-errors/errors v1.5.1 go get命令会调用git clone方法下载源码，并编译，最终会把库源码文件编译成归档文件安装到pkg对应的相关平台目录下。\n引入了 go module 后，go get变化 使用 go module 之后，go get拉取依赖的方式就发生了变化。\n拉取最新的版本（优先择取 tag） $ go get golang.org/x/text@latest 拉取 master 分支的最新 commit $ go get golang.org/x/text@master 拉取 tag 为 v0.3.2 的 commit $ go get golang.org/x/text@v0.3.2 拉取 hash 为 342b231 的 commit，最终会被转换为其对应的 tag 号 $ go get golang.org/x/text@342b2e 拉取指定版本，如指定版本 v3 $ go get github.com/smartwalle/alipay/v3 更新 $ go get -u 配置 GOPROXY 由于国内网络问题，可以将如下配置内容加入~/.bashrc或~/.bash_profile for bash，~/.zshrc或~/.zprofile for zsh.\ngo env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.io,https://proxy.golang.org,direct go env -w GOSUMDB=\u0026#34;sum.golang.google.cn\u0026#34; go mod go mod用于 Go 模块支持，包括初始化、添加依赖等。\n$ go help mod Go mod provides access to operations on modules. Note that support for modules is built into all the go commands, not just \u0026#39;go mod\u0026#39;. For example, day-to-day adding, removing, upgrading, and downgrading of dependencies should be done using \u0026#39;go get\u0026#39;. See \u0026#39;go help modules\u0026#39; for an overview of module functionality. Usage: go mod \u0026lt;command\u0026gt; [arguments] The commands are: download download modules to local cache edit edit go.mod from tools or scripts graph print module requirement graph init initialize new module in current directory tidy add missing and remove unused modules vendor make vendored copy of dependencies verify verify dependencies have expected content why explain why packages or modules are needed Use \u0026#34;go help mod \u0026lt;command\u0026gt;\u0026#34; for more information about a command. go mod init 初始化一个新模块，并在当前目录下创建go.mod文件。\n$ mkdir hello $ cd hello $ go mod init xxx.com/hello go: creating new go.mod: module xxx.com/hello $ cat go.mod module xxx.com/hello go 1.23.9 go mod tidy 清理未使用的依赖项，并更新go.mod文件。\ngo mod download 下载当前模块及其所有直接和间接依赖。\ngo mod vendor 将依赖项复制到vendor目录中，便于离线部署。\ngo test go test用于运行 Go 程序的测试。\ngo test命令会自动读取源码目录下面名为 *_test.go 的文件，生成并运行测试用的可执行文件。\n默认的情况下，不需要任何的参数，go test命令会自动把源码包下面所有 test 文件测试完毕，当然也可以带上参数，详情可以参考go help test。\ngo test -v可用于打印每个测试函数的名字和运行时间。\ngo test -bench=.可用于运行基准测试。\n-run对应一个正则表达式，只有测试函数名被正确匹配的测试函数才会被go test测试命令运行，如：go test -run=^$\ngo clean go clean用于删除当前源码包里面编译生成的文件。\ngo fmt go fmt用于自动格式化 Go 源代码。\n比如我们写了一个格式很糟糕的test.go文件，我们只需要使用go fmt test.go命令，就可以让 go 帮我们格式化我们的代码文件。但是我们一般很少使用这个命令，因为我们的开发工具一般都带有保存时自动格式化功能，这个功能底层其实就是调用了go fmt命令。\n使用go fmt命令，更多时候是用gofmt，而且需要参数-w，否则格式化结果不会写入文件。\ngo vet go vet用于对 Go 代码进行静态分析，检查可能存在的错误。若代码无问题，则没有输出\ngo doc go doc用于查看 Go 语言标准库或你的代码库中的文档。\n执行：\n$ go doc fmt.Println 输出：\npackage fmt // import \u0026#34;fmt\u0026#34; func Println(a ...any) (n int, err error) Println formats using the default formats for its operands and writes to standard output. Spaces are always added between operands and a newline is appended. It returns the number of bytes written and any write error encountered. go list go list命令可以查看项目的依赖，其中-m选项表示列出模块而不是包。\ngo list -m all列出当前模块及其依赖项的所有模块和版本。 go list -m -u all列出当前模块及其依赖项的所有模块和版本，及可用的最新版本。 go env go env用于打印 Go 的环境信息。\n执行：\n$ go env 输出：\nGO111MODULE=\u0026#39;on\u0026#39; GOARCH=\u0026#39;arm64\u0026#39; GOBIN=\u0026#39;\u0026#39; GOCACHE=\u0026#39;/Users/xxx/Library/Caches/go-build\u0026#39; GOENV=\u0026#39;/Users/xxx/Library/Application Support/go/env\u0026#39; GOEXE=\u0026#39;\u0026#39; GOEXPERIMENT=\u0026#39;\u0026#39; GOFLAGS=\u0026#39;\u0026#39; GOHOSTARCH=\u0026#39;arm64\u0026#39; GOHOSTOS=\u0026#39;darwin\u0026#39; GOINSECURE=\u0026#39;\u0026#39; GOMODCACHE=\u0026#39;/Users/xxx/go/1.23.9/pkg/mod\u0026#39; GONOPROXY=\u0026#39;\u0026#39; GONOSUMDB=\u0026#39;\u0026#39; GOOS=\u0026#39;darwin\u0026#39; GOPATH=\u0026#39;/Users/xxx/go/1.23.9\u0026#39; GOPRIVATE=\u0026#39;\u0026#39; GOPROXY=\u0026#39;https://goproxy.io,https://proxy.golang.org,direct\u0026#39; GOROOT=\u0026#39;/Users/xxx/.goenv/versions/1.23.9\u0026#39; GOSUMDB=\u0026#39;sum.golang.google.cn\u0026#39; GOTMPDIR=\u0026#39;\u0026#39; GOTOOLCHAIN=\u0026#39;auto\u0026#39; GOTOOLDIR=\u0026#39;/Users/xxx/.goenv/versions/1.23.9/pkg/tool/darwin_arm64\u0026#39; GOVCS=\u0026#39;\u0026#39; GOVERSION=\u0026#39;go1.23.9\u0026#39; GODEBUG=\u0026#39;\u0026#39; GOTELEMETRY=\u0026#39;local\u0026#39; GOTELEMETRYDIR=\u0026#39;/Users/xxx/Library/Application Support/go/telemetry\u0026#39; GCCGO=\u0026#39;gccgo\u0026#39; GOARM64=\u0026#39;v8.0\u0026#39; AR=\u0026#39;ar\u0026#39; CC=\u0026#39;clang\u0026#39; CXX=\u0026#39;clang++\u0026#39; CGO_ENABLED=\u0026#39;1\u0026#39; GOMOD=\u0026#39;/dev/null\u0026#39; GOWORK=\u0026#39;\u0026#39; CGO_CFLAGS=\u0026#39;-O2 -g\u0026#39; CGO_CPPFLAGS=\u0026#39;\u0026#39; CGO_CXXFLAGS=\u0026#39;-O2 -g\u0026#39; CGO_FFLAGS=\u0026#39;-O2 -g\u0026#39; CGO_LDFLAGS=\u0026#39;-O2 -g\u0026#39; PKG_CONFIG=\u0026#39;pkg-config\u0026#39; GOGCCFLAGS=\u0026#39;-fPIC -arch arm64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -ffile-prefix-map=/var/folders/r5/g9x6_d5n4z14jk1sxp27j9ch0000gn/T/go-build4084107366=/tmp/go-build -gno-record-gcc-switches -fno-common\u0026#39; go version go version用于打印当前 Go 的版本信息。\n执行：\n$ go version 输出：\ngo version go1.23.9 darwin/arm64 ","permalink":"https://docodex.github.io/posts/tech/go-cmd/","summary":"\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ go \u003cspan class=\"nb\"\u003ehelp\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eGo is a tool \u003cspan class=\"k\"\u003efor\u003c/span\u003e managing Go \u003cspan class=\"nb\"\u003esource\u003c/span\u003e code.\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eUsage:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tgo \u0026lt;command\u0026gt; \u003cspan class=\"o\"\u003e[\u003c/span\u003earguments\u003cspan class=\"o\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eThe commands are:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tbug         start a bug report\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tbuild       compile packages and dependencies\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tclean       remove object files and cached files\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tdoc         show documentation \u003cspan class=\"k\"\u003efor\u003c/span\u003e package or symbol\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tenv         print Go environment information\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tfix         update packages to use new APIs\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tfmt         gofmt \u003cspan class=\"o\"\u003e(\u003c/span\u003ereformat\u003cspan class=\"o\"\u003e)\u003c/span\u003e package sources\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tgenerate    generate Go files by processing \u003cspan class=\"nb\"\u003esource\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tget         add dependencies to current module and install them\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tinstall     compile and install packages and dependencies\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tlist        list packages or modules\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tmod         module maintenance\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\twork        workspace maintenance\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\trun         compile and run Go program\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\ttelemetry   manage telemetry data and settings\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nb\"\u003etest\u003c/span\u003e        \u003cspan class=\"nb\"\u003etest\u003c/span\u003e packages\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\ttool        run specified go tool\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tversion     print Go version\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tvet         report likely mistakes in packages\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eUse \u003cspan class=\"s2\"\u003e\u0026#34;go help \u0026lt;command\u0026gt;\u0026#34;\u003c/span\u003e \u003cspan class=\"k\"\u003efor\u003c/span\u003e more information about a command.\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eAdditional \u003cspan class=\"nb\"\u003ehelp\u003c/span\u003e topics:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tbuildconstraint build constraints\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tbuildmode       build modes\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tc               calling between Go and C\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tcache           build and \u003cspan class=\"nb\"\u003etest\u003c/span\u003e caching\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tenvironment     environment variables\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tfiletype        file types\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tgo.mod          the go.mod file\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tgopath          GOPATH environment variable\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tgoproxy         module proxy protocol\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\timportpath      import path syntax\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tmodules         modules, module versions, and more\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tmodule-auth     module authentication using go.sum\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tpackages        package lists and patterns\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tprivate         configuration \u003cspan class=\"k\"\u003efor\u003c/span\u003e downloading non-public code\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\ttestflag        testing flags\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\ttestfunc        testing functions\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tvcs             controlling version control with GOVCS\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eUse \u003cspan class=\"s2\"\u003e\u0026#34;go help \u0026lt;topic\u0026gt;\u0026#34;\u003c/span\u003e \u003cspan class=\"k\"\u003efor\u003c/span\u003e more information about that topic.\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"通用选项\"\u003e通用选项\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e选项\u003c/th\u003e\n          \u003cth\u003e作用\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003ccode\u003e-a\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e用于\u003cstrong\u003e强制重新编译所有涉及的 Go 语言代码包\u003c/strong\u003e（包括 Go 语言标准库中的代码包），\u003cstrong\u003e即使它们已经是最新的了\u003c/strong\u003e。该标记可以让我们有机会通过改动底层的代码包做一些实验。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003ccode\u003e-n\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e使命令\u003cstrong\u003e仅打印其执行过程中用到的所有命令，而不去真正执行它们\u003c/strong\u003e。如果只想查看或者验证命令的执行过程，而不想改变任何东西，使用它正好合适。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003ccode\u003e-v\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e用于\u003cstrong\u003e打印命令执行过程中涉及的代码包（列出被编译的代码包名称）\u003c/strong\u003e。这一定包括我们指定的目标代码包，并且有时还会包括该代码包直接或间接依赖的那些代码包。这会让你知道哪些代码包被执行过了。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003ccode\u003e-work\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e用于\u003cstrong\u003e打印命令执行时生成和使用的临时工作目录的名字，且命令执行完成后不删除它\u003c/strong\u003e。这个目录下的文件可能会对你有用，也可以从侧面了解命令的执行过程。\u003cstrong\u003e如果不添加此标记，那么临时工作目录会在命令执行完毕前删除\u003c/strong\u003e。\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003ccode\u003e-x\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e使命令打印其执行过程中用到的所有命令，\u003cstrong\u003e并同时执行它们\u003c/strong\u003e。（而\u003ccode\u003e-n\u003c/code\u003e参数是不真正执行它们）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003ccode\u003e-race\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e用于\u003cstrong\u003e检测并报告指定 Go 语言程序中存在的数据竞争问题\u003c/strong\u003e。当用 Go 语言编写并发程序的时候，这是很重要的检测手段之一。\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"go-run\"\u003e\u003ccode\u003ego run\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ego run\u003c/code\u003e命令用于编译并运行 Go 程序。\u003c/p\u003e","title":"Go 常用命令"},{"content":"$ cargo help Rust\u0026#39;s package manager Usage: cargo [+toolchain] [OPTIONS] [COMMAND] cargo [+toolchain] [OPTIONS] -Zscript \u0026lt;MANIFEST_RS\u0026gt; [ARGS]... Options: -V, --version Print version info and exit --list List installed commands --explain \u0026lt;CODE\u0026gt; Provide a detailed explanation of a rustc error message -v, --verbose... Use verbose output (-vv very verbose/build.rs output) -q, --quiet Do not print cargo log messages --color \u0026lt;WHEN\u0026gt; Coloring [possible values: auto, always, never] -C \u0026lt;DIRECTORY\u0026gt; Change to DIRECTORY before doing anything (nightly-only) --locked Assert that `Cargo.lock` will remain unchanged --offline Run without accessing the network --frozen Equivalent to specifying both --locked and --offline --config \u0026lt;KEY=VALUE|PATH\u0026gt; Override a configuration value -Z \u0026lt;FLAG\u0026gt; Unstable (nightly-only) flags to Cargo, see \u0026#39;cargo -Z help\u0026#39; for details -h, --help Print help Commands: build, b Compile the current package check, c Analyze the current package and report errors, but don\u0026#39;t build object files clean Remove the target directory doc, d Build this package\u0026#39;s and its dependencies\u0026#39; documentation new Create a new cargo package init Create a new cargo package in an existing directory add Add dependencies to a manifest file remove Remove dependencies from a manifest file run, r Run a binary or example of the local package test, t Run the tests bench Run the benchmarks update Update dependencies listed in Cargo.lock search Search registry for crates publish Package and upload this package to the registry install Install a Rust binary uninstall Uninstall a Rust binary ... See all commands with --list See \u0026#39;cargo help \u0026lt;command\u0026gt;\u0026#39; for more information on a specific command. cargo new cargo new命令用来创建一个新的 Rust 项目：\n--bin: 创建一个二进制程序项目(src/main.rs)，这也是不带选择时的默认行为。 $ cargo new hello_world --bin $ cd hello_world $ tree . ├── Cargo.toml └── src └── main.rs # 入口文件 2 directories, 2 files --lib: 创建一个库项目(src/lib.rs)。 $ cargo new hello_world --lib $ cd hello_world $ tree . ├── Cargo.toml └── src └── lib.rs # 默认库 2 directories, 2 files cargo init cargo init命令用来在现有目录中初始化一个新的 Rust 项目：\n--bin: 初始化一个二进制程序项目(src/main.rs)，这也是不带选择时的默认行为。 $ mkdir hello_world $ cargo init hello_world --bin $ cd hello_world $ tree . ├── Cargo.toml └── src └── main.rs # 入口文件 2 directories, 2 files --lib: 初始化一个库项目(src/lib.rs)。 $ mkdir hello_world $ cargo init hello_world --lib $ cd hello_world $ tree . ├── Cargo.toml └── src └── lib.rs # 默认库 2 directories, 2 files cargo build cargo build命令用来编译项目和项目依赖。\ncargo build: 编译输出二进制文件，放入target/debug目录。 cargo build --release: 输出二进制文件，放入target/release目录。 cargo run cargo run命令用来编译并运行 Rust 项目。\ncargo check cargo check命令用来快速检查代码能否编译通过。cargo check命令快速编译项目，而不会生成二进制文件，主要用来检查是否存在错误。\ncargo update cargo update命令用来更新Cargo.lock中定义的依赖包的版本。\ncargo clean cargo clean命令用来清除编译生成的文件。\ncargo fmt cargo fmt命令使用rustfmt格式化代码。\ncargo clippy cargo clippy命令运行clippy来进行代码审查。\ncargo clippy --all-targets -- --D warnings: Linter 检查错误 cargo test cargo test命令用来编译并运行项目中的单元测试、集成测试及文档测试等测试用例。\ncargo test: 运行所有测试用例。 cargo test test_foo: 指定函数过滤器，开头为test_foo的函数都会运行，例如(test_foo_bar). cargo test --package rustt --lib -- foo::bar::tests::test_foo --exact --nocapture: 指定特定模块中的测试函数(通常可以简写 cargo test foo::bar::tests::test_foo)。 cargo test --package rustt --lib -- foo::bar::tests --nocapture: 指定特定测试的模块(通常可以简写 cargo test foo::bar::tests)。 cargo tree cargo tree命令用来显示项目依赖树。\ncargo search cargo search命令用来在crates.io上搜索crate。\ncargo install cargo install命令用来安装和管理 Rust 二进制文件。\ncargo uninstall cargo uninstall命令用来卸载通过 Cargo 安装的 Rust 二进制文件。\ncargo version cargo version命令显示 cargo 版本信息。\n$ cargo version cargo 1.87.0 (99624be96 2025-05-06) 附：项目目录结构惯例 . ├── Cargo.lock ├── Cargo.toml ├── benches # 基准目录 │ └── large-input.rs ├── examples # 示例 │ └── simple.rs ├── src # 源代码 │ ├── bin │ │ └── another_executable.rs │ ├── lib.rs # 默认库 │ └── main.rs # 入口文件 └── tests # 集成测试 └── some-integration-tests.rs Cargo.toml和Cargo.lock存储在项目的根目录中。 源代码进入src目录。 默认库文件是src/lib.rs。 默认的可执行文件是src/main.rs。 其他可执行文件，可以放入src/bin/*.rs。 集成测试进入tests目录（单元测试进到，正在测试的每个文件中）。 示例进入examples目录。 基准进入benches目录。 ","permalink":"https://docodex.github.io/posts/tech/rust-cargo-cmd/","summary":"\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ cargo \u003cspan class=\"nb\"\u003ehelp\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eRust\u003cspan class=\"s1\"\u003e\u0026#39;s package manager\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003eUsage: cargo [+toolchain] [OPTIONS] [COMMAND]\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e       cargo [+toolchain] [OPTIONS] -Zscript \u0026lt;MANIFEST_RS\u0026gt; [ARGS]...\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003eOptions:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e  -V, --version                  Print version info and exit\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e      --list                     List installed commands\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e      --explain \u0026lt;CODE\u0026gt;           Provide a detailed explanation of a rustc error message\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e  -v, --verbose...               Use verbose output (-vv very verbose/build.rs output)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e  -q, --quiet                    Do not print cargo log messages\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e      --color \u0026lt;WHEN\u0026gt;             Coloring [possible values: auto, always, never]\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e  -C \u0026lt;DIRECTORY\u0026gt;                 Change to DIRECTORY before doing anything (nightly-only)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e      --locked                   Assert that `Cargo.lock` will remain unchanged\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e      --offline                  Run without accessing the network\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e      --frozen                   Equivalent to specifying both --locked and --offline\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e      --config \u0026lt;KEY=VALUE|PATH\u0026gt;  Override a configuration value\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e  -Z \u0026lt;FLAG\u0026gt;                      Unstable (nightly-only) flags to Cargo, see \u0026#39;\u003c/span\u003ecargo -Z help\u003cspan class=\"s1\"\u003e\u0026#39; for details\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e  -h, --help                     Print help\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003eCommands:\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e    build, b    Compile the current package\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s1\"\u003e    check, c    Analyze the current package and report errors, but don\u0026#39;\u003c/span\u003et build object files\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    clean       Remove the target directory\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    doc, d      Build this package\u003cspan class=\"s1\"\u003e\u0026#39;s and its dependencies\u0026#39;\u003c/span\u003e documentation\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    new         Create a new cargo package\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    init        Create a new cargo package in an existing directory\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    add         Add dependencies to a manifest file\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    remove      Remove dependencies from a manifest file\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    run, r      Run a binary or example of the \u003cspan class=\"nb\"\u003elocal\u003c/span\u003e package\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    test, t     Run the tests\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    bench       Run the benchmarks\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    update      Update dependencies listed in Cargo.lock\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    search      Search registry \u003cspan class=\"k\"\u003efor\u003c/span\u003e crates\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    publish     Package and upload this package to the registry\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    install     Install a Rust binary\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    uninstall   Uninstall a Rust binary\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    ...         See all commands with --list\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eSee \u003cspan class=\"s1\"\u003e\u0026#39;cargo help \u0026lt;command\u0026gt;\u0026#39;\u003c/span\u003e \u003cspan class=\"k\"\u003efor\u003c/span\u003e more information on a specific command.\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"cargo-new\"\u003e\u003ccode\u003ecargo new\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ecargo new\u003c/code\u003e命令用来\u003cstrong\u003e创建\u003c/strong\u003e一个新的 Rust 项目：\u003c/p\u003e","title":"Rust 常用 cargo 命令"},{"content":"在计算机基础中，原码、反码、补码和移码都是用于表示和处理有符号整数的编码方式。它们各自具有不同的定义和用途。\n原码直接使用二进制表示数值，并用最高位表示符号位（0 表示正数，1 表示负数）。 正数的原码是其二进制本身；负数的原码是符号位为 1，数值部分取其绝对值的二进制。例如，使用 8 位二进制表示，+3 的原码为 00000011，-3 的原码为 10000011。 原码的优点是直观，容易理解。然而，原码的缺点是加法和减法运算复杂，需要额外的规则来处理符号位。 反码是将正数保持不变，负数按位取反（符号位不变）。符号位仍然存在，仍然用最高位表示。 正数的反码和原码相同；负数是符号位为 1，其它位是原码取反。例如，+3 的反码仍为 00000011，-3 的反码为 11111100。 反码的优点是加减法运算规则简单，只需对应位相加并进位。然而，反码的缺点是存在两个零值：正零和负零。 补码是将反码中的正数保持不变，负数按位取反（符号位不变）再加 1。符号位仍然存在，仍然用最高位表示。 为了解决反码的正零和负零问题，补码被引入。 正数的补码和原码，反码相同；负数是符号位为 1，其它位是原码取反，末位加 1。例如，+3 的补码仍为 00000011，-3 的补码为 11111101。 补码的优点是只有一个零值，可以直接进行加减运算，而不需要额外的规则。补码还有一个重要的特性是能够通过减法运算实现加法，从而简化了计算机的逻辑电路设计。 用一张图表示如下： 为什么需要反码？ 我们可以将反码的作用类比成数学中的负数。\n对于小学生来说，会做的算术题是：5 - 3，但是不会做 3 - 5。于是，我们上初中的时候，数学里就引进了一个新的概念：负数。引入负数之后，本来是减法的运算就可以变成加法来实现：\n3 - 5 = 3 + [-5] = [-2]，中括号代表“负数”，“负数”就是我们人为给出的数学术语。\n对于计算机来说，会做的算术题是：5 + 3，但是不会做 3 - 5。于是，我们就在编码里引进了一个新的概念：反码。引入反码之后，本来是减法的运算就可以变成加法来实现：\n3 - 5 = 3 + [-5] = [-2]，中括号代表“反码”，“反码”就是我们人为给出的计算机术语。\n这里，你一定有一个疑问：为什么计算机只会做 5 + 3，不会做 3 - 5。这是因为在计算机的数字电路中只有加法器，没有所谓的“减法器”。不是说计算机厂商不会设计减法器，因为聪明的人既然发明了方法能够用加法来实现减法操作，那为什么还需要画蛇添足的弄一个减法器？\n接着说：那么反码要怎么定义才能实现减法变加法的功能呢？聪明的人想的办法如下：\n1.正数的反码保持原码不变：3=[0_0000011] 2.负数除最高位（正负符号位）外，全部取反（0 变 1，1 变 0）：-5=1_0000101，取反 =[1_1111010]\n于是 3+[-5]=[-2] 的计算过程为：\n0_0000011 + 1_1111010 ------------ 1_1111101 这样，这种反码方法就成功实现了目标！\n为什么需要补码？ 都是因为“0”这个特殊数字的存在。\n先问你一个问题：0 是正数还是负数？你肯定会说：0 既不是正数也不是负数，这是我们初中学到的数学知识。这个回答没有问题，所以每次碰到 0，人们都不会把它当正数或负数。\n那么计算机呢？计算机不同于人脑，计算机在碰到任何数字之前只根据最高位的符号位来判断正负性，“0”表示正数,“1”表示负数。\n前面我们推论了为何要用反码，那么用 8 位二进制反码表示的正数范围：+0 ～ +127；负数范围：-127 ～ -0。但是，其中有两个特殊的编码会出现：\n+0=[0_0000000]（反码） -0=[1_1111111]（反码）\n其实，+0 和 -0 代表的都是 0。**这样一来，“0”这个数字在计算机中的编码就不是唯一的了。**对于计算机来说，这是绝对不行的，因为任何数字都只能有 1 个编码。\n于是，聪明的人就做了这样一个决定：把 0 当成正数，也即 +0，这样 0 的编码就变成：0_0000000。那8位二进制表示的正数范围仍然是：+0 ~ +127。\n但是，对于负数就必须要做调整，也即 -0 必须要让位：1_1111111 这个编码不能表示 -0。我们可以把负数整体向后“挪动 1 位”：只要将 8 位二进制表示的负数范围从：-127 ～ -0 变成：-128 ～ -1，就能成功解决问题。\n那么怎么整体挪动1位呢？方法就是反码 +1。[1_1111111] 编码就不再表示 -0，而变成了 -1。顺着推，最小的编码 [1_0000000] 就是 -128。\n我们给这个反码 +1 又人为的取了一个新的名字，叫补码。于是乎，补码的定义如下：\n正数的补码保持原码不变。如：3=[0_0000011] 负数先求反码，然后再加 1。如：-5=[1_1111010]+1=[1_1111011] 于是 3+[-5]=[-2] 的计算过程为：\n0_0000011 + 1_1111011 ------------ 1_1111110 至此，通过补码就成功解决了数字 0 在计算机中非唯一编码的问题，且也能实现减法变加法。\n所以，在计算机的世界里，0 是正数。这点和我们学的数学不一样。\n[0_1111111]=+127（补码） [0_0000000]=+0（补码） [1_1111111]=-1（补码） [1_0000000]=-128（补码） 负数最低位 (-1) + (-127) = [1_0000001]原 + [1_1111111]原 = [1_1111111]补 + [1_0000001]补 = [1_0000000]补\n-1-127 的结果应该是 -128，在用补码运算的结果中，[1_0000000]补就是 -128。但是注意因为实际上是使用以前的 -0 的补码来表示 -128，所以 -128并没有原码和反码表示。（对 -128 的补码表示 [1_0000000]补算出来的原码是 [0_0000000]原, 这是不正确的）\n使用补码, 不仅仅修复了 0 的符号以及存在两个编码的问题，而且还能够多表示一个最低数。这就是为什么 8 位二进制, 使用原码或反码表示的范围为 [-127, +127]，而使用补码表示的范围为[-128, 127] == [[1_0000000]补, [0_1111111]补] == [-27, 27-1]\n因为机器使用补码，所以对于编程中常用到的 32 位 int 类型，可以表示范围是：[-231, 231-1] 因为第一位表示的是符号位。而使用补码表示时又可以多保存一个最小值。\n浮点数 二进制小数 在介绍浮点数之前先来看看二进制中实数可以如何表示。假设我有一个十进制的小数 8.33，那么它的值可以表示为：\n8 + 3 / 10 + 3 / 100 = 833 / 100 各个位的权重依次是 100 = 1, 10-1 = 0.1, 10-2 = 0.01。其实二进制小数也是类似的，只不过它是逢二进一。考虑这个二进制串 1001.1111，它所能够代表的十进制数字是多少呢？简单地可以把它分成整数部分 1001 以及小数部分 1111。\n整数部分的计算很容易了，在不考虑符号的情况下依次代入相关的权重即可：\n1 * 2 ^ 3 + 0 * 2 ^ 2 + 0 * 2 ^ 1 + 1 * 2 ^ 1 = 9 小数部分其实类似，只不过相关的权重需要稍微调整一下：\n1 * (2 ^ -1) + 1 * (2 ^ -2) + 1 * (2 ^ -3) + 1 * (2 ^ -4) = 1 / 2 + 1 / 4 + 1 / 8 + 1 / 16 = 15 / 16 再换个角度去看这个小数的部分，其实它还等价于 1111 / 10000：\n(1 * 2 ^ 3 + 1 * 2 ^ 2 + 1 * 2 ^ 1 + 1 * 2 ^ 0) / (2 ^ 4) = 15 / 16 就是先计算二进制串 1111 的值，再把它的小数点往左移动 4 位，因此需要除以 2 ^ 4。结合整数部分以及小数部分，可以得到最终结果 9 + (15 / 16) = 159 / 16。\n如果用已有的二进制编码知识来表示数值 159 / 16，那么只需要分配一段内存区域来存储 159 的二进制串 10011111，然后再利用另一段区域来存储小数点相关的偏移量 00000100 即可。不过这种方式灵活性比较低，所能够表示的数值范围也十分有限。那么接下来看看现代机器中浮点数是如何表示的。\nIEEE 浮点数 基于前面所谈到的原理，再来理解 IEEE 浮点数就比较容易了。\n基本原理 IEEE浮点数的计算方式稍微有点麻烦，使用的科学计数法。假设我有一个十进制小数 100.2 那么其实这个数可以表示为 0.1002 * (102)，可以简单地概括成这条公式 N * (10K)，把这条公式放到二进制领域就是 M * (2E)。其中 M 是该浮点数的尾数，主要影响浮点数的精度。E 是浮点数的阶码，主要影响浮点数的大小。\nIEEE 浮点表示会把一个二进制串分成 3 部分，分别用来存储浮点数的尾数，阶码以及代表浮点数正负的符号位。不过在IEEE浮点数中尾数以及阶码并不是直接存储的，而是需要特殊的编码方式。\n不同精度的浮点数 IEEE 浮点数主要分为单精度浮点数以及双精度浮点数，分别对应 C 语言里面的float和double两种类型。\n单精度浮点数通过 32 位的二进制串来表示。其中 022 位（23位长）用来存储尾数，23～30 位（8位长）用来存储阶码，第 31 位为最高有效位用来表示浮点数的符号。它的示意图大概如下： 双精度浮点数所能够表示的精度更大，范围更广。它用 051 位（52位长）用来存储尾数，52～62 位（11位长）用来存储阶码，第 63 位为最高有效位用于表示浮点数的符号，它的示意图大概如下： C 语言里甚至还有long double这种数据类型，可以通过下面的代码来测试它的字节长度：\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;%ld\u0026#34;, sizeof(long double)); } 在我的器上的运行结果是 16 个字节长，也就是 16 * 8 = 128 位长。不过这种类型在不同的机器或者操作系统上表现可能会有所不同，移植性较差，不建议使用。\n浮点数的计算方式 简单起见，这里用 32 位的浮点数来详细地描述一下 IEEE 浮点数值的相关计算方式。在 32 位二进制串中，阶码部分用 8 位来存储，尾数部分用 23 位来存储，还有 1 位是符号位。\n偏置量与符号位 在讲具体计算之前先来了解两个特殊值，分别是偏置量以及符号位。\n偏置量 Bias 是一个用于计算阶码的特殊值。它的数值跟存储阶码的位长有关，当阶码位长为 k 的时候偏置量的值为 2k-1，具体用途稍后会讲到。另外一个需要注意的就是最高有效位，这个位利用原码的相关知识，充当了浮点数的符号位。最高有效位为 0 的时候这个浮点数是正数，最高有效位为 1 的时候这个浮点数是负数。也就是说在 IEEE 浮点数中会出现 +0.0 或者 -0.0 这样的数值。\n二进制位的不同“模式”将会有不一样的数值计算方式，不过这两个特殊值的理念在任何情况下几乎是通用的。\n规格化浮点数 规格化浮点数的特点是存储阶码的位既不全为 0 也不全为 1，存储尾数的位可以随意定制。示意图如下： 可以推断出阶码部分所能够表示的无符号数取值范围是 1~254。这种情况下需要配合偏置量来求具体阶码 E 的值\nE = e - Bias 因此，阶码值的取值范围是 -126 ～ 127。接下来看尾数部分，在规格化的情况下尾数的位模式代表了小数点后面的数值，我们把这部分用 f 表示。不过这还不是真实的尾数，我们还需要把这个数值加 1。于是有\nM = 1 + f 举个例子，假设用于存储尾数的位串是 11000000000000000000000，那么在规格化表示中，尾数的实际数值其实是 1.11000000000000000000000。利用这些原理，尝试计算下面的规格化数\n1 01111111 10000000000000000000000 最高有效位为 1，所以该浮点数所表示的数值始终小于或等于 0。 阶码部分以无符号的方式去解读可得 127，那么实际阶码的值是 E = e - Bias = 127 - 127 = 0。 尾数部分在规格化数的计算中需要把数值加 1 来求得真实的尾数值，所以有 M = 1 + f = 1 + 0.10000000000000000000000 = 1.10000000000000000000000 因此位串所代表的浮点数值是 -1.10000000000000000000000 * (20) = -(1 + 1/2) * 1 = -(3 / 2) = -1.5。其实并不是很难对吧？接下来看非规格化数的计算方式。\n非规格化浮点数 非规格化浮点数的特点就是用于存储阶码的所有位全为 0，存储尾数的位可以随意定制。非规格化浮点数主要用于表示那些非常接近于0的数。示意图如下 只是它的计算方式跟规格化数相比还是有点区别的，在非规格化浮点表示中，用于存储阶码的 8 位全为 0，因此阶码所表示的无符号数始终为 0。这个时候偏置量 Bias 依然是 28 - 1 = 127。不过阶码值 E 的计算方式却是\nE = 1 - Bias 而不是 E = 0 - Bias，这有点违反直觉。不过这都是为了跟规格化浮点数进行一个平滑过渡。\n接下来看尾数部分，在规格化浮点数中尾数部分所表示的数值始终需要加 1，这种时候尾数的范围是 1 \u0026lt;= M \u0026lt; 2。而在非规格化表示中尾数部分直接就是存储了真实的尾数值，不需要再进行别的运算了，于是有\nM = f 这时尾数的范围是 0 \u0026lt;= M \u0026lt; 1。因此在非规格化表示中尾数部分 10000000000000000000000 所对应的尾数值就是 0.10000000000000000000000\n利用这些原理来计算一个非规格化浮点数\n0 00000000 11100000000000000000000 最高有效位为 0，所以该浮点数所表示的数值始终大于或者等于 0。 作为一个非规格化数阶码部分全为 0，因此阶码值始终是 1 - Bias = 1 - 127 = -126。 尾数部分直接表示了对应的尾数值 M = f = 0.11100000000000000000000 因此位串所代表的浮点数值是 0.11100000000000000000000 * (2-126) = (1 / 2 + 1 / 4 + 1 / 8) * (2-126) = (7 / 8) * (2-126)。这个值大概是等于 1.0285575569695016e-38（我应该没算错吧^_^），这是一个非常小的数值。非规格化浮点数的计算方式与规格化差不多，只是处理起来稍稍有点特殊，这都是为了两者间的平滑过渡。\n关于平滑过渡 我们可以通过具体示例来看看非规格化数与规格化数之间如何平滑地过渡，根据前面的原理我们还能得出一个结论，就是非规格数始终会比规格化数小。那么他们之间的过渡便可以看成是从最大非规格化数过渡到最小规格化数了（假设数值都是大于 0 的）。\n利用前面所讲过的浮点数的原理，我们简单地用一个 8 位二进制串来看这个过渡的过程，假设最高有效位为符号位，其中 3 位存储阶码，4 位存储尾数。在数值大于 0 的情况下，最大非规格化数表示为\n0 000 1111 最小规格化数是\n0 001 0000 这个时候大家偏置量都是2 ^ 3 - 1 = 7。如果我们的非规格化数 00001111 的阶码部分按照 E = 0 - e 来计算的话，那么此时的非规格化数的值就是 (2 ^ (0 - 7)) * (15 / 16) = 15 / 2048。而规格化数 00010000 的值是 (2 ^ (1 - 7)) * 1 = 16 / 1024 = 32 / 2048。似乎差点意思对吧？\n但如果按照标准的计算方式，用 E = 1 - e 来计算非规格化数阶码的话，此时浮点数 00001111 的数值是 (2 ^ (1 - 7)) * (15 / 16) = 15 / 1024。这个时候它跟最小规格化数值 16 / 1024 的差距就非常小了，这就是所谓的平滑过渡。\nOK，讲完了需要计算的东西，以及它们之间的平滑过渡，接下来再看一些不需要详细计算的特殊值。\n特殊值 以上两种表示方式已经能够涵盖大量的浮点数了，不过在某些情况下我们要有正无穷，负无穷，以及 NaN 这些特殊值来使编程更加简便，那么在 IEEE 浮点数中这些特殊值要如何表示呢？\n无穷 在 IEEE 浮点数中无穷的特征是阶码的部分的位全为 1，尾数部分的位全为 0。示意图如下 前面已经谈论过，最高有效位始终代表着浮点数的符号，用于标识正负。这个理论知识在无穷中依然有用。因此在这种模式下，最高有效位为 0 的时候表示正无穷\n0 11111111 00000000000000000000000 最高有效位为1的时候表示负无穷\n1 11111111 00000000000000000000000 NaN 另外一个特殊值是 NaN，NaN 翻译过来就是 Not A Number，它的特征是阶码部分全为1的同时，尾数部分不全为 0。示意图如下 这种时候无论符号位是 0 还是 1，它始终都是代表着 NaN。\n","permalink":"https://docodex.github.io/posts/tech/number/","summary":"\u003cp\u003e在计算机基础中，原码、反码、补码和移码都是用于表示和处理有符号整数的编码方式。它们各自具有不同的定义和用途。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e原码直接使用二进制表示数值，并用最高位表示符号位（0 表示正数，1 表示负数）。\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e正数的原码是其二进制本身；负数的原码是符号位为 1，数值部分取其绝对值的二进制。例如，使用 8 位二进制表示，+3 的原码为 00000011，-3 的原码为 10000011。\u003c/li\u003e\n\u003cli\u003e原码的优点是直观，容易理解。然而，原码的缺点是加法和减法运算复杂，需要额外的规则来处理符号位。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e反码是将正数保持不变，负数按位取反（符号位不变）。符号位仍然存在，仍然用最高位表示。\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e正数的反码和原码相同；负数是符号位为 1，其它位是原码取反。例如，+3 的反码仍为 00000011，-3 的反码为 11111100。\u003c/li\u003e\n\u003cli\u003e反码的优点是加减法运算规则简单，只需对应位相加并进位。然而，反码的缺点是存在两个零值：正零和负零。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e补码是将反码中的正数保持不变，负数按位取反（符号位不变）再加 1。符号位仍然存在，仍然用最高位表示。\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e为了解决反码的正零和负零问题，补码被引入。\u003c/li\u003e\n\u003cli\u003e正数的补码和原码，反码相同；负数是符号位为 1，其它位是原码取反，末位加 1。例如，+3 的补码仍为 00000011，-3 的补码为 11111101。\u003c/li\u003e\n\u003cli\u003e补码的优点是只有一个零值，可以直接进行加减运算，而不需要额外的规则。补码还有一个重要的特性是能够通过减法运算实现加法，从而简化了计算机的逻辑电路设计。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e用一张图表示如下：\n\u003cimg loading=\"lazy\" src=\"./images/number-1.png\" alt=\"原码、反码、补码\"  /\u003e\n\u003c/p\u003e","title":"数字编码"},{"content":" 凡事尽心尽力，而后，顺其自然！\n慌张，是因为准备不足； 急躁，是因为经历不够； 心乱，是因为思路不清； 轻浮，是因为磨砺不多； 心累，是因为想法太多； 压力，是因为期望过高； 贪婪，是因为欲望太满； 懒散，是因为目标不明； 骄傲，是因为目光短浅； 暴躁，是因为自身无能； 恐惧，是因为要求过盛； 憎恨，是因为肚量不够。\n","permalink":"https://docodex.github.io/about/","summary":"about","title":"About"}]